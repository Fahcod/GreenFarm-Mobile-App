Letâ€™s carefully break this down step by step so you have a backend + MongoDB design that handles:

Access & refresh tokens

Multi-device login

Token theft detection

Secure, scalable flow

1ï¸âƒ£ Token storage model in MongoDB

You want a user schema that can store multiple refresh tokens (for multi-device support) and allow token rotation:

const userSchema = new mongoose.Schema({
  name: String,
  email: String,
  password: String,
  // array of active refresh tokens
  refreshTokens: [
    {
      token: String,
      deviceId: String,       // optional: identify device
      createdAt: Date,
      lastUsedAt: Date
    }
  ],
});

Why array of tokens?

Each device has its own refresh token

You can invalidate a single device if compromised

You can track last used timestamps â†’ detect suspicious activity

2ï¸âƒ£ Login flow (multi-device)

User logs in from device â†’ backend:

Generates access_token (short)

Generates refresh_token (long)

Saves refresh token in refreshTokens array with deviceId

Returns both tokens to client

user.refreshTokens.push({ token: refreshToken, deviceId });
await user.save();

3ï¸âƒ£ Refresh token flow (rotation)

When access_token expires â†’ client calls /refresh with refresh_token

Backend finds token in user.refreshTokens

If found:

Generate new access_token + new refresh_token

Replace old refresh_token with new one (rotation)

If token not found â†’ possible theft â†’ log out all devices

// pseudo code
const tokenIndex = user.refreshTokens.findIndex(rt => rt.token === oldRefreshToken);
if (tokenIndex === -1) {
  // token theft detected!
  user.refreshTokens = []; // invalidate all devices
  await user.save();
  return res.status(403).json({ message: "Token invalidated" });
}

// rotate token
user.refreshTokens[tokenIndex] = { token: newRefreshToken, deviceId, lastUsedAt: new Date() };
await user.save();

4ï¸âƒ£ Logout flow

Single device logout â†’ remove refresh token from array

All devices logout â†’ empty the array

user.refreshTokens = user.refreshTokens.filter(rt => rt.deviceId !== currentDeviceId);
await user.save();

5ï¸âƒ£ Detecting token theft

Keep lastUsedAt and deviceId

If refresh token reused after rotation â†’ mark as compromised â†’ log out all devices

Optional: send email / notification to user

6ï¸âƒ£ Security best practices

Store refresh tokens securely (hashed if desired)

Set short expiration for access tokens (e.g., 15m)

Limit refresh token lifespan (e.g., 7â€“30 days)

Implement rate-limiting for refresh endpoint

7ï¸âƒ£ React Native + Backend integration

React Native stores refresh token securely (Keychain / SecureStore)

Axios interceptor retries failed requests with new access token

Multi-device support â†’ each device has its own refresh token

Backend rotation + array â†’ ensures token theft detection & revocation

Fahad Mental Model
Device logs in â†’ gets access + refresh
  â†“
Access expires â†’ call refresh endpoint
  â†“
Backend checks refresh in array
  â”œâ”€ if found â†’ rotate + issue new access token
  â””â”€ if not found â†’ possible theft â†’ logout all devices
Device logs out â†’ remove refresh token from array


ğŸ’¡ Bottom line:

Multi-device login + rotation + token theft detection = production-grade auth

MongoDB is perfect for this because arrays + atomic updates make it easy to manage multiple tokens per user

Fahad, if you want, I can draw a full diagram showing React Native + Node + Mongo + multi-device + token rotation flow, so you can visualize exactly how it works in production.

Do you want me to do that?